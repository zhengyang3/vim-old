"Cscope Usage 
"Usage:
"#######  cd ~/src/project
"#######  find path1 path2 -name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.java" >> cscope.files  (find可以同时指定多个路径)
"#######  cscope -bq         (update datebase automatically)                      

"Ctag Usage
"#######  ctags -L cscope.files    or   ctags –R


"all plugins: 
"MRU 
"CommandT 
"pathogen
"watchman
"Nerdtree
"tagbar
"minibufexplorer
"grep
"quickfix
"Cscope
"easymotion
"expand-region


set nu
set ignorecase
set smartcase
"set keywordprg=dic
"set hlsearch
set incsearch 
set foldenable
set foldmethod=indent
set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
"nnoremap <space> @=((foldclosed(line('.')) < 0) ? 'zc' : 'zo')<CR>
nmap <space> <C-d>
nmap B <C-u>
nmap gp "0p
nmap gP "0P
set relativenumber

set t_Co=256


let mapleader = ","
let g:mapleader = ","


nmap <leader>r :MRU<CR>

execute pathogen#infect()
syntax on
filetype plugin indent on

noremap <leader>t :CommandT<CR>
set wildignore+=*.o,*.obj,.git,*.pyc,*.ko,out
let g:CommandTCancelMap=['<Esc>', '<C-c>']
let g:CommandTMaxFiles=500000
let g:CommandTMaxCachedDirectories=20
let g:CommandTFileScanner = 'watchman'


nmap <leader>f :NERDTreeToggle<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
let g:NERDTreeDirArrows=0


nmap <leader>a :TagbarToggle<CR>
let tagbar_left=1
let tagbar_autofocus=1
let tagbar_map_help = "&"

"map <C-j> <C-W>j
"map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

map <C-k> <C-T>
map <C-j> <C-]>


map K <C-y>
map J <C-e>
nnoremap <leader>J J

nnoremap <silent> <F3> :Grep -rnsi<CR>
nmap <leader>q :q!<cr>
nmap <leader>j :bn<cr>
nmap <leader>k :bp<cr>
nmap <leader>d ]c

nmap <leader>W ?(<cr>
nmap <leader>E ?"<cr>




"" Gif config
"map  / <Plug>(easymotion-sn)
"omap / <Plug>(easymotion-tn)
"
"let g:EasyMotion_do_mapping = 0 " Disable default mappings
"
"" Jump to anywhere you want with minimal keystrokes, with just one key binding.
"" `s{char}{label}`
"nmap f <Plug>(easymotion-f)
"" or
"" `s{char}{char}{label}`
"" Need one more keystroke, but on average, it may be more comfortable.
"nmap s <Plug>(easymotion-f2)
"
"" Turn on case insensitive feature
"let g:EasyMotion_smartcase = 1
"
"" JK motions: Line motions
"map <Leader>j <Plug>(easymotion-j)
"map <Leader>k <Plug>(easymotion-k)


"Ctags config: the ; must be added,otherwise the file of Tags canot be loaded automatically
set tags=tags;
set autochdir



"Cscope Usage and Config
"Usage:
"#######  cd ~/src/project
"#######  find . -name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.java" > cscope.files 
"#######  cscope -bq         (update datebase automatically)                      

if has("cscope") 
"    set cscopequickfix=s-,c-,d-,i-,t-,e- 
    set cscopetag 
    "0 cscope fist; 1 ctags first
    set csto=1 
    if filereadable("cscope.out")   
        cs add cscope.out   
    "else search cscope.out elsewhere   
    else   
       let cscope_file=findfile("cscope.out", ".;")   
       let cscope_pre=matchstr(cscope_file, ".*/")   
       if !empty(cscope_file) && filereadable(cscope_file)   
           exe "cs add" cscope_file cscope_pre   
       endif             
     endif 
    set cscopeverbose 

    nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR> 
    nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR> 
    nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR> 
    nmap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR> 
    nmap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR> 
    nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR> 
    nmap <C-\>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR> 
    nmap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR> 
endif

if &diff  
	syntax off
	"colorscheme elflord
    highlight! link DiffText MatchParen
    highlight DiffAdd         term=bold ctermbg=4  " bg: dark blue, fg: black 
    highlight DiffChange cterm=bold ctermfg=33 ctermbg=68  gui=none guifg=bg guibg=Red
    "highlight DiffChange cterm=bold ctermfg=20 ctermbg=88  gui=none guifg=bg guibg=Red
    highlight DiffDelete     term=bold cterm=bold ctermfg=4 ctermbg=6 " bg: DarkCyan, fg: dark blue 
    highlight DiffText cterm=bold ctermfg=30 ctermbg=88  gui=none guifg=bg guibg=Red
endif  


" allows incsearch highlighting for range commands
cnoremap $t <CR>:t''<CR>
cnoremap $T <CR>:T''<CR>
cnoremap $m <CR>:m''<CR>
cnoremap $M <CR>:M''<CR>
cnoremap $d <CR>:d<CR>``






" // The switch of the Source Explorer 
nmap <F8> :SrcExplToggle<CR> 
" // Set the height of Source Explorer window 
let g:SrcExpl_winHeight = 8 
" // Set 100 ms for refreshing the Source Explorer 
let g:SrcExpl_refreshTime = 100 
" // Set "Enter" key to jump into the exact definition context 
" let g:SrcExpl_jumpKey = "<ENTER>" 
" // Set "Space" key for back from the definition context 
let g:SrcExpl_gobackKey = "<SPACE>" 
" // In order to Avoid conflicts, the Source Explorer should know what plugins 
" // are using buffers. And you need add their bufname into the list below 
" // according to the command ":buffers!" 
let g:SrcExpl_pluginList = [ 
        \ "__Tag_List__", 
        \ "_NERD_tree_", 
        \ "Source_Explorer" 
    \ ] 
" // Enable/Disable the local definition searching, and note that this is not 
" // guaranteed to work, the Source Explorer doesn't check the syntax for now. 
" // It only searches for a match with the keyword according to command 'gd' 
let g:SrcExpl_searchLocalDef = 1 
" // Do not let the Source Explorer update the tags file when opening 
let g:SrcExpl_isUpdateTags = 0 
" // Use 'Exuberant Ctags' with '--sort=foldcase -R .' or '-L cscope.files' to 
" //  create/update a tags file 
let g:SrcExpl_updateTagsCmd = "ctags --sort=foldcase -R ." 
" // Set "<F12>" key for updating the tags file artificially 
let g:SrcExpl_updateTagsKey = "<F12>" 





vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)


"Mark plugin config
nmap  <Leader>s <Plug>MarkRegex
nmap <Leader>M <Plug>MarkToggle 
nmap <Leader>N <Plug>MarkAllClear 


vnoremap <silent> s //e<C-r>=&selection=='exclusive'?'+1':''<CR><CR>
    \:<C-u>call histdel('search',-1)<Bar>let @/=histget('search',-1)<CR>gv
omap s :normal vs<CR>

nmap <C-Up>   <Plug>(LineJugglerBlankUp)
nmap <C-Down> <Plug>(LineJugglerBlankDown)
vmap <C-Up>   <Plug>(LineJugglerBlankUp)
vmap <C-Down> <Plug>(LineJugglerBlankDown)
let g:LineJuggler_DupRangeOver= [9, '[%dD', ']%dD']
let g:LineJuggler_DupOverRange= [9, '[%dd', ']%dd']



























" vim-plug
call plug#begin('~/.vim/plugged')

" Bare necessities
Plug 'tpope/vim-surround'
Plug 'scrooloose/syntastic'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-vinegar'
Plug 'ironhouzi/vim-stim'
Plug 'tpope/vim-commentary'

" Utilities
Plug 'bling/vim-airline'
Plug 'sjl/gundo.vim'
Plug 'tpope/vim-dispatch'
Plug 'michaeljsmith/vim-indent-object'
Plug 'osyo-manga/vim-over'
Plug 'jpalardy/vim-slime'
Plug 'junegunn/vim-easy-align'
Plug 'tommcdo/vim-exchange'
Plug 'ludovicchabant/vim-gutentags'
Plug 'guns/vim-sexp', { 'for': ['scheme', 'clojure', 'racket', 'lisp'] }

" Unite
Plug 'Shougo/unite.vim'
Plug 'Shougo/neomru.vim'
Plug 'rking/ag.vim'
Plug 'Shougo/vimproc.vim', { 'do': 'make' }

" Python
Plug 'bps/vim-textobj-python', { 'for': 'python' }
Plug 'kana/vim-textobj-user', { 'for': 'python' }
Plug 'tmhedberg/SimpylFold', { 'for': 'python' }

" Snippets
Plug 'SirVer/ultisnips'
Plug 'home:m/git_repos/myultisnippets.git'

" Markdown
Plug 'tpope/vim-markdown', { 'for': 'markdown' }
Plug 'jtratner/vim-flavored-markdown', { 'for': 'markdown' }

" Colour schemes
Plug 'jonathanfilip/vim-lucius'
Plug 'endel/vim-github-colorscheme'

" Unmanaged plugin (manually installed and updated)
Plug '~/code/bikey-vim'

call plug#end()

filetype plugin indent on       " load file type plugins + indentation
set omnifunc=syntaxcomplete#Complete    " activate omnicompletion
syntax on                       " enable syntax highlighting
set backspace=indent,eol,start  " backspace through everything in insert mode

set encoding=utf-8
set fileencoding=utf-8
scriptencoding utf-8

set hidden
set undofile
set ignorecase          " searches are case insensitive...
set smartcase           " ... unless they contain at least one capital letter
set showcmd             " display incomplete commands
set nowrap              " No wrapping when coding
set nohls               " search highlighting off is better for arbitrary jumps
set number              " Line numbering
set autoindent          " indent at the same level of the previous line
set nosmartindent       " Doesn't mess up filetype indentation
set nomodeline          " Haven't found a good use for modelines yet
set wildmenu            " tab completion

" set pastetoggle=<F12>   " pastetoggle (sane indentation on pastes)
set scrolloff=5         " scrolls 5 lines before reaching the very top or bottom
set sidescroll=2        " only scroll horizontally little by little
set ttyfast             " improves redrawing for newer computers

set tabstop=4           " tabs are 4 characters long
set shiftwidth=4        " < and > use indents of 4 spaces
set softtabstop=4       " let backspace delete indent
set expandtab           " tabs are spaces, not tabs
set incsearch           " highlights searches for efficient movement
set autowrite           " save on buffer switch
set autochdir           " automaticly update cwd to your buffer

set wildignore=*.o,*.obj,*.jpg,*.png,*.pdf,*.pyc,*.tgz,*.txz,*.zip,*.7z,*.rar
set textwidth=80
set formatoptions=qrn1j

" toggle invisible characters
set listchars=tab:▸\ ,eol:¬,trail:⌴,extends:❯,precedes:❮
set showbreak=↪

" Don't try to highlight lines longer than 800 characters.
set synmaxcol=800

" Thank you Steve Losh
set notimeout
set ttimeout
set ttimeoutlen=10

let mapleader = ","
let maplocalleader = "\\"

" ----- Backup -------------------------
set backup
set noswapfile

set undodir=~/.vim/tmp/undodir//
set backupdir=~/.vim/tmp/backup//

if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), "p")
endif

if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif

if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
" ---------------------------------------

" ----------------------------------------------------------------------------
"       Au rules
" ----------------------------------------------------------------------------

" save on losing focus (NOT WORKING)
" autocmd FocusLost * silent! wall

" Resize splits when the window is resized
au VimResized * :wincmd =

" Different settings for html files
autocmd FileType html,xml,htmldjango :setlocal sw=2 ts=2 sts=2
autocmd FileType python :setlocal ts=8 sw=4 sts=4 et
autocmd FileType markdown :Prose

" " Set plugin for markdown
" augroup markdown
"     "au!
"     au BufNewFile,BufRead *.md,*.markdown setlocal filetype=markdown
" augroup END

" Make sure Vim returns to the same line when you reopen a file.
augroup line_return
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" Fix unresponsive editing of TeX files
autocmd FileType tex :NoMatchParen
au FileType tex setlocal nocursorline

" ----------------------------------------------------------------------------

if $TERM == "xterm-256color" || $TERM == "screen-256color"
    colorscheme virgin_aquatic
endif

" ----------------------------------------------------------------------------
"       FOLDING  -- In progress
" ----------------------------------------------------------------------------
set foldlevelstart=1

" Make zO recursively open whatever fold we're in, even if it's partially open.
nnoremap zO zczO

function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" Mappings {{{

" HIGHLIGHTING -----------------------------------------
" correct highlighting is controlled by the vim-stim plugin
" ensure that search highlighting is off for regular search
nnoremap / :set nohlsearch nohlsearch?<CR>/

" Toggle search highlighting and clear all matches
nnoremap <silent> <leader><space> :set hlsearch! hlsearch?<CR>:call clearmatches()<CR>
" ------------------------------------------------------

" %% expands to current working directory
cnoremap %% <c-r>=expand('%:h').'/'<cr>

" gs saves
noremap gs :w<CR>

" toggle Gundo
nnoremap <leader>gu :GundoToggle<CR>

" Cleanup trailing whitespace in entire file
nnoremap <leader>w :silent! %s/\s\+$//<cr>:let @/=''<CR>:w<CR>

" Fat finger correction
nmap Ø :
command! -nargs=* Q q <args>
command! -nargs=* W w <args>
command! -nargs=* Wq wq <args>

" allows incsearch highlighting for range commands
cnoremap $t <CR>:t''<CR>
cnoremap $T <CR>:T''<CR>
cnoremap $m <CR>:m''<CR>
cnoremap $M <CR>:M''<CR>
cnoremap $y <CR>:y''<CR>
cnoremap $d <CR>:d<CR>``

" Select entire code block
nnoremap gb vaBok0

" Easier linewise reselection of what you just pasted.
nnoremap <leader>v V`]

" Indent/dedent/autoindent what you just pasted.
nnoremap <lt>> V`]<
nnoremap ><lt> V`]>
nnoremap =- V`]=

" Auto fold
nmap <F6> VaBo0zf

" Proper copy/paste
:map <F7> :w !xclip<CR><CR>
:vmap <F7> :w !xclip<CR><CR>

" Alt-] opens tag in vsplit
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

" resize windows
nnoremap <silent> <Leader>+ :exe "resize " . (winheight(0) * 3/2)<CR>
nnoremap <silent> <Leader>- :exe "resize " . (winheight(0) * 2/3)<CR>
" increase current pane size
nnoremap <silent> <Leader>> :exe "vertical resize " . (winwidth(0) * 3/2)<CR>
" decrease current pane size
nnoremap <silent> <Leader>< :exe "vertical resize " . (winwidth(0) * 2/3)<CR>

" Refresh busted syntax highlighting
map <F12> :syntax sync fromstart<cr>

" switch between current and last buffer
nnoremap <leader>. <c-^>

" Emacs bindings in command mode
cnoremap <C-a> <Home>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-d> <Delete>
cnoremap <M-b> <S-Left>
cnoremap <M-f> <S-Right>
cnoremap <M-d> <S-right><Delete>
cnoremap <C-g> <C-c>

" Uppercase line when in insert mode (NB: messes with register z)
inoremap <C-u> <esc>mzgUiw`za

" Keep the cursor in place when joining lines
nnoremap J mzJ`z

" Zip Right (Steve Losh)
" Once you hit escape your cursor is on the closing paren, so you can 'zip' it
" over to the right with this mapping. Also preserves your last yank/delete.
" print()'some text' --------(zl)---------> print('some text')
"       ^------- cursor is here
 nnoremap zl :let @z=@"<cr>x$p:let @"=@z<cr>

" wipe buffer
nnoremap <leader>wq :bwipeout<cr>
" close window
nnoremap <leader>ww :wincmd q<cr>

" equalize windows
nnoremap <leader>= <C-w>=

" set working directory to current file
nnoremap <leader>cd :cd %:p:h<CR>:pwd<CR>

" replace i with j (for quick copy/pasting for-loop definitions
noremap <leader>ij :s/\<i\>/j/g<CR>:noh<CR>

" execute macro over visual range
xnoremap @ :<C-u>call ExecuteMacroOverVisualRange()<CR>

" perform dot command in visal mode
vnoremap . :norm.<CR>

" easy-align ----------------------------
vnoremap <silent> <Enter> :EasyAlign<Enter>

" Vim-Over ------------------------------
" cabbrev s OverCommandLine<CR>s
" cabbrev %s OverCommandLine<CR>%s
cabbrev '<,'>s OverCommandLine<CR>'<,'>s

" Toggle Mode
" TODO: use a safer check than checking wrap setting
nnoremap com :<C-R>=&wrap ? 'Code' : 'Prose'<CR><CR>

" Highlights words in six different colours
nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" ------- FZF - fuzzy finder ------------
if isdirectory($HOME .'/.fzf')
    set rtp+=~/.fzf
    nnoremap <leader>r :FZF<CR>
endif

" ------- UNITE.VIM ---------------------

let g:unite_data_directory = "~/.vim/tmp/unite_cache"

" Regular fuzzy search
nnoremap <silent> <leader>f :<C-u>Unite
    \ -buffer-name=files file file_mru buffer<CR>

nnoremap <silent> <leader>c :<C-u>Unite file_rec<CR>

" Content searching (ack.vim/ag.vim)
nnoremap <space>/ :<C-u>Unite grep -buffer-name=search
    \ -auto-preview -no-quit -no-empty<CR>

" Buffer searching
nnoremap <silent> g/ :<C-u>Unite
    \ line:forward -start-insert -no-quit<CR>
nnoremap <silent> g? :<C-u>Unite
    \ line:backward -start-insert -no-quit<CR>

" Yank history
let g:unite_source_history_yank_enable = 1
nnoremap <space>y :Unite history/yank<cr>

call unite#filters#matcher_default#use(['matcher_fuzzy'])

call unite#custom#source('file_rec',
    \ 'sorters', 'sorter_rank')

call unite#custom_source('file_rec,file_rec/async,file_mru,file,buffer,grep',
      \ 'ignore_pattern', join([
      \ '\.git/',
      \ 'tmp/',
      \ '.pyc',
      \ ], '\|'))

function! s:unite_settings()
  nmap <buffer> <ESC> <Plug>(unite_insert_enter)
  imap <buffer> <ESC> <Plug>(unite_exit)
  imap <buffer> <c-j> <Plug>(unite_insert_leave)
  nmap <buffer> <c-j> <Plug>(unite_loop_cursor_down)
  nmap <buffer> <c-k> <Plug>(unite_loop_cursor_up)
  nmap <buffer> <tab> <Plug>(unite_loop_cursor_down)
  nmap <buffer> <s-tab> <Plug>(unite_loop_cursor_up)
  imap <buffer> <c-a> <Plug>(unite_choose_action)
  imap <buffer> <Tab> <Plug>(unite_insert_leave)
  imap <buffer> <C-w> <Plug>(unite_delete_backward_word)
  imap <buffer> <C-u> <Plug>(unite_delete_backward_path)
  nmap <buffer> <C-r> <Plug>(unite_redraw)
  imap <buffer> <C-r> <Plug>(unite_redraw)
endfunction

" Custom mappings for the unite buffer
autocmd FileType unite call s:unite_settings()

if executable('ag')
    " Use ag in unite grep source.
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts =
                \ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
                \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt = ''
endif

" Start in insert mode
let g:unite_enable_start_insert = 1

" --------------- netrw -----------------
"  Don't switch back to netrw buffer with ctrl-^ (<leader>.)
let g:netrw_altfile = 1
" ---------------------------------------

" --------------- Bikey-Vim -------------
inoremap <c-l> <esc>:call SwitchKbd()<cr>a
" ---------------------------------------

" --------------- Fugitive --------------
set diffopt=vertical
nnoremap <leader>gi :Git<space>
nnoremap <leader>gs :Gstatus<CR>
nnoremap <leader>gl :Git log --all --graph --decorate --oneline<CR>

" Open current buffer in a new tab and show Fugitive diff
nnoremap <silent> <leader>d :tab split \| Gdiff \| wincmd h<cr>
" ---------------------------------------

"  --------- SYNTASTIC ------------------
" Open location list for syntastic
map <leader>lo :lw<CR>
map <leader>lc :lcl<CR>
" map <leader>cn :cc<CR>
" Goto first warning/error
map <leader>ll :llist<CR>
map <leader>ln :lne<CR>
map <leader>lp :lp<CR>

let g:syntastic_always_populate_loc_list=0
let g:syntastic_enable_signs=0                          " required for location list
let g:syntastic_java_checkers = ['javac']
let g:syntastic_python_checkers=['flake8']              " depends on flake!
let g:syntastic_cpp_compiler='g++'
let g:syntastic_cpp_compiler_options=' -std=c++11'
let g:bufferline_echo = 0                       " Doesn't interfere with the bufferline
"let g:syntastic_auto_jump=1                    " jumps to first error
" ---------------------------------------

"  AIRLINE ------------------------------
let g:airline_section_z = '%3p%% %{g:airline_symbols.linenr}%#__accent_bold#%4l%#__restore__#:%3v'
let g:airline_section_c = '%t'
let g:airline_left_sep = ''
let g:airline_right_sep = ''
let g:airline#extensions#branch#enabled = 1
" let g:airline_fugitive_prefix = '⎇ '
let g:airline#extensions#tabline#enabled = 0    " Extended tab bar on top

" Truncate legend:
" ----------------
" a: mode, paste, iminsert
" b: hunks, branch
" c: bufferline, filename
" x: tagbar, filetype, virtualenv
" y: fileencoding, fileformat
" z: percentage, line number, column number
let g:airline#extensions#default#section_truncate_width = {
    \ 'a': 45,
    \ 'b': 45,
    \ 'c': 45,
    \ 'x': 74,
    \ 'y': 45,
    \ 'z': 74,
    \ }

" Sets javapath to parent directory
map <leader>j :cd %:p:h<CR>:pwd<CR>:SyntasticJavacEditClasspath<CR>:r !pwd<CR>$dawkdd:w<CR>
" map <leader>cp :cd ~/sys/libs/algs4<CR>:pwd<CR>:SyntasticJavacEditClasspath<CR>:r !pwd<CR>$dawkdd:w<CR>

" ----------------------------------------------------------------------------
" move to the window in the direction shown, or create a new split in that
" direction
" ----------------------------------------------------------------------------
func! WinMove(key)
    let t:curwin = winnr()
    exec "wincmd ".a:key
    if (t:curwin == winnr())
        if (match(a:key,'[jk]'))
            wincmd v
        else
            wincmd s
        endif
        exec "wincmd ".a:key
    endif
endfu

nnoremap <silent> <C-h> :call WinMove('h')<cr>
nnoremap <silent> <C-j> :call WinMove('j')<cr>
nnoremap <silent> <C-k> :call WinMove('k')<cr>
nnoremap <silent> <C-l> :call WinMove('l')<cr>
" MAPPING ENDS }}}

" ULTINIPS ------------------------------
let g:UltiSnipsSnippetsDir = "~/.vim/plugged/myultisnippets/UltiSnips"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
" ---------------------------------------

" ----------------------------------------------------------------------------
"  STATUSLINE
" ----------------------------------------------------------------------------
" let g:netrw_list_hide = '.*\.(swp|pyc|pdf|jpg|png)$'
" let g:netrw_list_hide = '.*\.jpg$'
" ----------------------------------------------------------------------------

" ----------------------------------------------------------------------------
"  STATUSLINE
" ----------------------------------------------------------------------------
if has('statusline')
    set laststatus=2
    " set noshowmode " Hide default mode (-- INSERT -- below the statusline)
    set showmode
endif
" ----------------------------------------------------------------------------

" ----------------------------------------------------------------------------
"  VIM-SLIME
" ----------------------------------------------------------------------------
let g:slime_target = "tmux"
let g:slime_paste_file = "$HOME/.slime_paste"
" ----------------------------------------------------------------------------

" ----------------------------------------------------------------------------
"  Specific settings for GUI mode
" ----------------------------------------------------------------------------
if has("gui_running")
    colorscheme virgin_aquatic
    set gfn=M+\ 1mn\ 10
    set guioptions-=r
    set guioptions-=T
    set guioptions-=m           " no gui menu
    set guioptions+=c           " use console dialogs

"   Regulates max columns of 80 characters
    highlight OverLength ctermbg=red ctermfg=white guibg=#592929
    match OverLength /\%80v.\+/
endif
" ----------------------------------------------------------------------------

" --------------
" Print settings
" --------------
set printoptions=number:y
" -----------------------

" FUNCTIONS {{{
" ----------------------------------------------------------------------------
"  Enable word processor mode
" ----------------------------------------------------------------------------
func! ProseMode()
    setlocal formatoptions=1
    map j gj
    map k gk
    setlocal spell
    silent setlocal spelllang=en_us,nb
    "set thesaurus+=/Users/sbrown/.vim/thesaurus/mthesaur.txt
    "set complete+=s
    setlocal formatprg=par
    setlocal nonumber
    setlocal wrap
    setlocal linebreak
    setlocal nolist

    "  max character highlighting in GUI
    if has("gui_running")
        hi clear OverLength
    endif

    augroup PROSE
        autocmd InsertEnter * set formatoptions+=a
        autocmd InsertEnter * set formatoptions-=a
    augroup END
endfu
com! Prose call ProseMode()

func! CodeMode()
    silent! iunmap <buffer> .
    silent! iunmap <buffer> !
    silent! iunmap <buffer> ?
    setlocal formatoptions=qrn1j
    setlocal nospell
    setlocal number
    setlocal nowrap
    setlocal nolinebreak

    if has("gui_running")
        highlight OverLength ctermbg=red ctermfg=white guibg=#592929
        match OverLength /\%106v.\+/
    endif

    silent! autocmd! PROSE * <buffer>
endfu
com! Code call CodeMode()

func! IRCMode()
    call ProseMode()
    imap <cr> <esc><Plug>SlimeLineSend
    nmap <cr> <Plug>SlimeLineSend
    let g:slime_default_config = {"socket_name": "default", "target_pane": '3.0'}
endfu
com! IRC call IRCMode()
" ----------------------------------------------------------------------------

function! ExecuteMacroOverVisualRange()
  echo "@".getcmdline()
  execute ":'<,'>normal @".nr2char(getchar())
endfunction

function! CopyMatches(reg)
  let hits = []
  %s//\=len(add(hits, submatch(0))) ? submatch(0) : ''/ge
  let reg = empty(a:reg) ? '+' : a:reg
  execute 'let @'.reg.' = join(hits, "\n") . "\n"'
endfunction
command! -register CopyMatches call CopyMatches(<q-reg>)
" }}}

" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}

function! ScratchEdit(cmd, options)
	exe a:cmd tempname()
	setl buftype=nofile bufhidden=wipe nobuflisted
	if !empty(a:options) | exe 'setl' a:options | endif
endfunction

command! -bar -nargs=* Scratch call ScratchEdit('edit', <q-args>)
command! -bar -nargs=* Ssplit call ScratchEdit('split', <q-args>)
command! -bar -nargs=* Svsplit call ScratchEdit('vsplit', <q-args>)
command! -bar -nargs=* Stabedit call ScratchEdit('tabe', <q-args>)
" }}}

"--------------
" Abbreviations
"--------------
iab Latex LaTeX
iab Xetex XeTeX
iab Xelatex XeLaTeX
iab Luatex LuaTeX
iab Lualatex LuaLaTeX
